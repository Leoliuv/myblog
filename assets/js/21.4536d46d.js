(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{197:function(t,s,e){"use strict";e.r(s);var a=e(0),r=Object(a.a)({},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"对慢查询日志进行分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对慢查询日志进行分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 对慢查询日志进行分析")]),t._v(" "),e("h5",{attrs:{id:"_1-使用mysqldumpslow进行分析【第一种方式】"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用mysqldumpslow进行分析【第一种方式】","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. "),e("strong",[t._v("使用mysqldumpslow进行分析")]),t._v("【第一种方式】")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("mysqldumpslow -t 10  host-172-18-231-118-slow.log  #显示出慢查询日志中最慢的1条sql\n")])])]),e("p",[e("img",{attrs:{src:"/ph/1570765860161.png",alt:"1570765860161"}})]),t._v(" "),e("h5",{attrs:{id:"_2-使用pt-query-digest工具进行分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用pt-query-digest工具进行分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.使用pt-query-digest工具进行分析")]),t._v(" "),e("p",[t._v("mysqldumpslow是mysql安装后就自带的工具，用于分析慢查询日志，但是pt-query-digest却不是mysql自带的，如果想使用pt-query-digest进行慢查询日志的分析，则需要自己安装pt-query-digest。pt-query-digest工具相较于mysqldumpslow功能多一点。")]),t._v(" "),e("ol",[e("li",[t._v("通过拷贝工具进行实现")]),t._v(" "),e("li",[t._v("查看具体参数作用")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pt-query-digest --help\n")])])]),e("p",[e("img",{attrs:{src:"/ph/1570772328830.png",alt:"1570772328830"}})]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[t._v("使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("pt-query-digest ./mysql01/mysql/21000/host-172-18-231-118-slow.log\n")])])])])]),t._v(" "),e("p",[e("img",{attrs:{src:"/ph/1570772455550.png",alt:"1570772455550"}})]),t._v(" "),e("p",[e("em",[t._v("查询结果分为三部分")])]),t._v(" "),e("p",[e("strong",[t._v("第一部分")]),t._v("：显示出了日志的时间范围，以及总的sql数量和不同的sql数量。")]),t._v(" "),e("p",[e("strong",[t._v("第二部分")]),t._v("：显示出统计信息。")]),t._v(" "),e("p",[e("strong",[t._v("第三部分")]),t._v("：每一个sql具体的分析")]),t._v(" "),e("p",[t._v("pct是percent的简写，表示占的百分比")]),t._v(" "),e("p",[t._v("cout是占总sql个数的百分比，exec time 是占总执行时间的百分比，lock time 表示占总的锁表时间的百分比。")]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("分析")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1）查询次数多且每次查询占用时间长的sql\n通常为pt-query-digest分析的前几个查询\n\n2）IO消耗大的sql\n注意pt-query-digest分析中的Rows examine项\n\n3）为命中索引的sql\n注意pt-query-digest分析中Rows examine（扫描行数） 和 Rows sent （发送行数）的对比 ，如果扫描行数远远大于发送行数，则说明索引命中率并不高。\n")])])]),e("h5",{attrs:{id:"_3-优化sql"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-优化sql","aria-hidden":"true"}},[t._v("#")]),t._v(" 3. 优化SQL")]),t._v(" "),e("h6",{attrs:{id:"_1-使用explain查询sql的执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用explain查询sql的执行计划","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 使用explain查询sql的执行计划")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("use test01;\nexplain select name,age from test01;\n")])])]),e("p",[e("img",{attrs:{src:"/ph/1570773017867.png",alt:"1570773017867"}})]),t._v(" "),e("p",[t._v("参数列表：")]),t._v(" "),e("ul",[e("li",[t._v("table：表示属于哪张数据表")]),t._v(" "),e("li",[t._v("type：最重要的参数，表示连接使用了何种类型。从最好到最差的连接类型为const，eq_reg，ref，range，index和ALL。")]),t._v(" "),e("li",[t._v("possible_keys：显示可能应用在这张表中的索引。如果为null，则表示没有可能的索引。")]),t._v(" "),e("li",[t._v("key：实际使用的索引。如果为null，则表示没有使用索引。")]),t._v(" "),e("li",[t._v("key_len：使用的索引的长度，在不损失精确性的情况下，长度越短越好。")]),t._v(" "),e("li",[t._v("ref：表示索引的哪一列被使用了，如果可能的话，是一个常数。")]),t._v(" "),e("li",[t._v("rows：Mysql认为必须检查的用来返回请求数据的行数。")])]),t._v(" "),e("h6",{attrs:{id:"_2-子查询优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-子查询优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.子查询优化")]),t._v(" "),e("p",[t._v("通常情况下，需要把子查询优化为join查询，但在优化时要注意关联键是否有一对多的关系，如果有，是可能会出现重复数据的。所以如果存在一对多关系，则应该使用distinct进行限制。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("eg:\nselect t.id from t where t.id in (select k.kid from k);\n优化：\nselect distinct t.id from t join k on t.id = k.kid;\n")])])]),e("h6",{attrs:{id:"对索引的优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对索引的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 对索引的优化")]),t._v(" "),e("ol",[e("li",[t._v("选择合适的列建立索引")]),t._v(" "),e("li",[t._v("索引优化SQL的方法")]),t._v(" "),e("li",[t._v("索引维护")])])])},[],!1,null,null,null);s.default=r.exports}}]);